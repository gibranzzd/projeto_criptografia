# -*- coding: utf-8 -*-
"""TRABALHO DIA 19/04 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B3CwYCf4on2dVwcw0Kdf_1D0bHAwp1fZ

# TRABALHO DOS ALUNOS
# ALISSON DALLA LASTA
# GIBRAN DEON
# 5° PERIODO
# ENGENHARIA DA COMPUTAÇÃO
# NOTURNO
"""

# Solicitar o texto a ser encriptado ou decriptado

texto = 'VASCO'

# Chave a ser utilizada

chave = 6

  # Determinar modo de operação (E = encriptar; D = decriptar)

modo = 'E'

  # Conjunto de caracteres válidos no algoritmo

CARACTERES = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

  # Variável para armazenar o texto criptografado (ou decifrado)

convertido = ''

  # Converter todo o texto em maiúsculas

texto = texto.upper()

  # Código que será executado em cada caractere do texto:

for caractere in texto:
  if caractere in CARACTERES:
    num = CARACTERES.find(caractere)
    if modo == 'E':
      num = num + chave
    if modo == 'D':
      num = num - chave

  # Manipular a rotação se o valor de num for maior do que o comprimento de CARACTERES ou menor que 0

    if num >= len(CARACTERES):
      num = num - len(CARACTERES)
    if num < 0:
      num = num + len(CARACTERES)

  # Adicionar (concatenar) o caractere correspondente a num na variável convertido

    convertido = convertido + CARACTERES[num]

  # Mostrar o texto encriptado ou decifrado na tela

if modo == 'E':
    print('O texto criptografado é ', convertido)
elif modo == 'D':
    print('O texto decriptado é ', convertido)
else:
    print('Opção inválida')

# ATIVIDADE 1

def vascodecrypt(gama, colina):
    plaintext = ""
    for caracter in gama:
        if caracter.isalpha():
            if caracter.islower():
                decriptadocaracter = chr(((ord(caracter) - ord('a') - colina) % 26) + ord('a'))
            else:
                decriptadocaracter = chr(((ord(caracter) - ord('A') - colina) % 26) + ord('A'))
        else:
            vascodecrypt = caracter
        plaintext += decriptadocaracter
    return plaintext

def decriptar(gama):
    for colina in range(26):
        decrypted_text = vascodecrypt(gama, colina)
        print(f"Shift {colina}: {decrypted_text}")

print("Texto cifrado:", convertido)
print("\nTentando todas as possíveis chaves:")
decriptar(convertido)

import hashlib

def open_txt(file):

  with open(file) as f:

    return "".join(f.read())

file_1 = 'a.txt'

file_2 = 'b.txt'

text_1 = open_txt(file_1)

text_2 = open_txt(file_2)

def compare(text_1, text_2):

  hash_1 = hashlib.md5()

  hash_1.update(text_1.encode('utf-8'))

  hash_1 = hash_1.hexdigest()

  hash_2 = hashlib.md5()

  hash_2.update(text_2.encode('utf-8'))

  hash_2 = hash_2.hexdigest()

  return hash_1, hash_2;

hash = compare(text_1, text_2)

print(hash[0])

print(hash[1])

# ATIVIDADE 2
import os
import hashlib

def gerarhashdapasta(pasta):
    hashes = {}
    for raiz, _, arquivos in os.walk(pasta):
        for arquivo in arquivos:
            caminho_arquivo = os.path.join(raiz, arquivo)
            with open(caminho_arquivo, 'rb') as f:
                hasher = hashlib.md5()
                while True:
                    bloco = f.read(4096)
                    if not bloco:
                        break
                    hasher.update(bloco)
                hash_arquivo = hasher.hexdigest()
                hashes[caminho_arquivo] = hash_arquivo
    return hashes

pasta = '/content/hash'

hashes = gerarhashdapasta(pasta)

for arquivo, hash_arquivo in hashes.items():
    print(f"Arquivo: {arquivo}, Hash: {hash_arquivo}")

def localizaiguais(pasta):
    hashes = {}
    arquivos_identicos = {}

    for raiz, _, arquivos in os.walk(pasta):
        for arquivo in arquivos:
            caminho_arquivo = os.path.join(raiz, arquivo)
            hash_arquivo = calcular_hash(caminho_arquivo)
            if hash_arquivo in hashes:
                arquivos_identicos[hash_arquivo] = arquivos_identicos.get(hash_arquivo, []) + [caminho_arquivo, hashes[hash_arquivo]]
            else:
                hashes[hash_arquivo] = caminho_arquivo

    return arquivos_identicos

pasta = '/content/hash'

arquivos_identicos = localizaiguais(pasta)

if arquivos_identicos:
    print("Os seguintes arquivos são idênticos:")
    for hash_arquivo, caminhos in arquivos_identicos.items():
        print(f"Hash: {hash_arquivo}")
        for caminho in caminhos:
            print(f"- {caminho}")
else:
    print("Não há arquivos idênticos na pasta.")

pip install pycryptodome

from Crypto.PublicKey import RSA

chave= RSA.generate(2048) # gera uma chave com 2048 bits

chave_privada = chave.export_key()

chave_publica = chave.publickey().export_key()

from Crypto.Cipher import PKCS1_OAEP

mensagem = b'hello word'

chave_publica_obj = RSA.import_key(chave_publica)

cifra = PKCS1_OAEP.new(chave_publica_obj)

texto_encriptado = cifra.encrypt(mensagem)

texto_encriptado

# ATIVIDADE 3
# A criptografia RSA consiste na utilização de uma chave pública (referindo-se a uma informação associada a alguém, porém distribuída a todos) e uma chave privada
# (informação pessoal que não é publicavel).
# É possível criptografar um dado utilizando a chave pública, e então os usuários que possuirem a chava privada podem descriptografar a mensagem.
# As chaves consistem em se multiplicar dois números primos, com o resultado sendo público.
# Porém, a depender do tamanho do número gerado, pode demorar anos para fatorá-lo e descobrir os números primos utilizados para formá-lo.

import string
from itertools import product
from time import time
from numpy import loadtxt

def product_loop(password, generator):
  for p in generator:
    if  ''.join(p) == password:
      print('\nSenha:', ''.join(p))
      return ''.join(p)
  return False

def bruteforce(password, max_nchar=8):
  print('1) Comparando com as senhas mais comuns e nomes iniciais/ do meio')
  common_pass = loadtxt('dicionario_senhas.txt', dtype=str)
  common_names = loadtxt('nomes_meio.txt', dtype=str)
  cp = [c for c in common_pass if c == password]
  cn = [c for c in common_names if c == password]
  cnl = [c.lower() for c in common_names if c.lower() == password]

  if len(cp) == 1:
    print('\nSenha:', cp)
    return cp
  if len(cn) == 1:
    print('\nSenha:', cn)
    return cn
  if len(cnl) == 1:
    print('\nSenha:', cnl)
    return cnl

  print('2) Senhas com números')
  for l in range(1, 9):
    generator = product(string.digits, repeat=int(l))
    print("\t..%d digito" % l)
    p = product_loop(password, generator)
    if p is not False:
      return p

  print('3) Digitos ASCII')
  for l in range(1, max_nchar + 1):
    print("\t..%d caracter" % l)
    generator = product(string.digits + string.ascii_lowercase,
repeat=int(l))

    p = product_loop(password, generator)
    if p is not False:
      return p

  print('4) Digitos + ASCII maiúsculo / minúsculo + pontuação')

# se falhar, ele começa a fazer pelo modo de força bruta do modo hard

# O que mesmo possible_char = string.printable[:-5]

  all_char = string.digits + string.ascii_letters + string.punctuation

  for l in range(1, max_nchar + 1):
    print("\t..%d char" % l)
    generator = product(all_char, repeat=int(l))
    p = product_loop(password, generator)
    if p is not False:
      return p

# Exemplo

start = time()
bruteforce('123456') # Tente com '123456' or '751345' or 'test2018'
end = time()
print('Total time: %.2f seconds' % (end - start))

# ATIVIDADE 4
import string
from itertools import product
from time import time
from numpy import loadtxt

def product_loop(password, generator):
    for p in generator:
        if ''.join(p) == password:
            print('\nSenha:', ''.join(p))
            return ''.join(p)
    return False

def bruteforce(password, max_nchar=8):
    print('1) Comparando com as senhas mais comuns e nomes iniciais/do meio')
    common_pass = loadtxt('dicionario_senhas.txt', dtype=str)
    common_names = loadtxt('nomes_meio.txt', dtype=str)
    cp = [c for c in common_pass if c == password]
    cn = [c for c in common_names if c == password]
    cnl = [c.lower() for c in common_names if c.lower() == password]

    if len(cp) == 1:
        print('\nSenha:', cp)
        return cp
    if len(cn) == 1:
        print('\nSenha:', cn)
        return cn
    if len(cnl) == 1:
        print('\nSenha:', cnl)
        return cnl

    print('2) Senhas com números')
    for l in range(1, 9):
        generator = product(string.digits, repeat=int(l))
        print("\t..%d digito" % l)
        p = product_loop(password, generator)
        if p is not False:
            return p

    print('3) Digitos ASCII')
    for l in range(1, max_nchar + 1):
        print("\t..%d caracter" % l)
        generator = product(string.digits + string.ascii_lowercase, repeat=int(l))
        p = product_loop(password, generator)
        if p is not False:
            return p

    print('4) Digitos + ASCII maiúsculo/minúsculo + pontuação + caracteres especiais')

    # Incluir caracteres especiais
    all_char = string.digits + string.ascii_letters + string.punctuation + '!@#$%^&*()_+-=[]{}|;:,.<>?'

    for l in range(1, max_nchar + 1):
        print("\t..%d char" % l)
        generator = product(all_char, repeat=int(l))
        p = product_loop(password, generator)
        if p is not False:
            return p

# Exemplo
start = time()
bruteforce('alizi')  # Tente com '123456' or '751345' or 'test2018'
end = time()
print('Total time: %.2f seconds' % (end - start))

# ATIVIDADE 5
# A senha de teste foi descoberta em 30.25 segundos
# Os sites e sistemas podem utilizar também além de senhas fortes:
# - VERIFICAÇÃO EM DUAS ETAPAS
# - CÓDIGOS ENVIADOS PARA VERIFICAÇÃO ATRAVÉS DO E-MAIL OU SMS
# - PERGUNTAS DE SEGURANÇAS PREDEFINIFIDAS PELO USUÁRIO NO CADASTRO
# - RECONHECIMENTO FACIAL E BIOMETRIA